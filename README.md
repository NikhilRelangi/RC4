# RC4
Spritz is Rivest and Scheldtâ€™s redesign of RC4. It retains all of the problems that RC4 had #teambuild

Suppose A (sender) and B (receiver) possess the same secure key (128 bits) to initialize RC4 state (S, i, j)A for A and (S, i, j)B for B and initially (S, i, j)A = (S, i, j)B = (S, i, j)o. Initially A and B also set their sequence counters to zero. Each data packet has 272 bytes (4 bytes for sequence counter value, 252 bytes for data segment and 16 bytes for hash value): 
For Sender: 
1. The sender divides the input plaintext message into contiguous 252-byte data segments and assigns SC to each of them. The sequence counter (SC) value is increased by 1 in increased order (initially SCA = 0). If there are not enough data in the data segment of the last data packet, pad a 1 followed by as many 0 as necessary. 
2. The sender calculates the hash value for that data packet by inputting SC and the unencrypted data segment, and then places the 128-bit hash value into the data packet. 
This appendix introduces RC4-BHF, an RC4 based hash function. The input of RC4-BHF is a message of arbitrary length up to 65536 bits and a non-negative integer which is called offset number. The maximum length of input message is 65536 bits and the output is a fixed-length hash value to be 128-bit long. The internal state of RC4-BHF is a 256-byte permutation. N is a non-negative integer which can be arbitrary length and we suppose the length of the input of RC4-BHF is N-bit. N can be zero, it can be arbitrarily large, and it does not need to be a multiple of eight. RC4-BHF performs the following steps to calculate the hash value from an input message: (1) Append Padding Bits and Length, and Divide the Padded Message, (2) Compression, and (3) Output. Algorithm 1 and Algorithm 2 give the pseudo code of KSA* and PRGA* respectively. In KSA* , we use Mk to produce output STATEMk from STATEk. This involves starting with S[0] and going through to S[255], and, for each S[i], swapping S[i] with another byte in S according to a scheme dictated by Mk[i]. For PRGA* , it produces STATEk from STATEMk. This involves starting with S[0] and going through to S[len], and, for each S[i], swapping S[i] with another byte in S according to a scheme dictated by the current configuration of S. 
Step 1: Append Padding Bits and Length, and Divide the Padded Message The input to this step is the input message of arbitrary length, and the output is one or multiple of 512-bit message blocks. The message is appended with padding bits and length so that the length in bits is congruent to 0, modulo 512. That is, the message is extended so that the length is an exact multiple of 512 bits. Padding is always performed, even if the length of the message is already congruent to 0, modulo 512. The appending process is illustrated in Figure 1. Appending padding bits is performed as follows: a single "1" bit is appended to the input message, and then "0" bits are appended so that the length in bits of the padded message becomes congruent to 496, modulo 512. In all, at least 1 bit and at most 512 bits are appended. A 16-bit representation of N (the length of the input message, before the padding bits were added) which we denote as L is 
appended to the result of the previous padding bits process. At this point the resulting message (after appending with padding bits and N) has a length that is an exact multiple of 512 bits. 
Step 2: Compression Figure 3 illustrates the compression process. M1 and the offset value, which is a non-negative integer, are inputted to initialize S. Note that M1 is treated as the key to the KSA algorithm. 
STATEM1 = PRGAâˆ— (offset, KSA(M1)) 
Then PRGA* updates S according to len1 as below: 
STATE1 = PRGAâˆ— (len1,STATEM1) 
where ğ‘™ğ‘’ğ‘›1 = { M1 mod 256 if (M1 mod 256) â‰  0 offset if (M1 mod 256) = 0 For ğ‘˜ > 1 (ğ‘˜ = 2, 3, â€¦ , ğ‘›), S are updated step by step as follows: 
STATEMk = KSAâˆ— (Mk,STATEkâˆ’1) 
STATEk = PRGAâˆ— (lenk,STATEMk) 
where ğ‘™ğ‘’ğ‘›ğ‘˜ = { Mk mod 256 if (Mk mod 256) â‰  0 offset if (Mk mod 256) = 0 
In the compression process, how many times PRGA* runs is controlled by lenk. Regarding how to calculate â€œMk mod 256â€, the default method is listed in the following: every 8 digits binary can convert to a non-negative integer between 0 and 255, since the length of Mk is 512 bits Mk can be divided into 64 1-byte blocks, then add them up, modulo 256 to calculate an integer as the result of â€œMk mod 256â€. For example, dividing a Mk into 64 1-byte blocks, such as 00000000 00000001 00000010 â€¦, the result of (ğ‘€ğ‘˜ ğ‘šğ‘œğ‘‘ 256) is (0 + 1 + 2 + â‹¯ ) ğ‘šğ‘œğ‘‘ 256 3. The sender produces the encrypted data packets by only encrypting data segment and hash value (do not encrypt SC value). The sender updates its SCA and (S, i, j)A after the encryption 
Step 3: Output The first part of the output step is performed as follows: Using the final output of the compression step, the 256-byte STATEn as the key to KSA, and then PRGA to generate a 512 bytes output, and discards the first 256 bytes and only keeps the last 256 bytes in the calculation. XORing STATEn with the last 256 bytes of the PRGA output to generate a 256-byte output which is denoted as O256. The process of the first part of the output step is illustrated in Figure 4. 8 The second part of the output step is used to reduce the size of the hash value, which is illustrated in Figure 5. The final hash value is generated from the least significant bit of each odd number and the final hash value is 128-bit long. 
For Receiver: Initially (S, i, j)B = (S, i, j)0 and SCB = 0. When receiving a new packet, B compares its own SC value (SCB) with the SC value of the packet. If the difference of the SC value of the packet and its own SC value (SCpacket - SCB) is 0, then (S, i, j)B is used as the RC4 state to decrypt the data segment and hash value of that incoming packet and then increase the sequence counter by 1. Otherwise, calculate the right RC4 state from current (S, i, j)B by applying certain rounds of PRGA or IPRGA, and then use the right RC4 state 3 to decrypt the data segment and hash 
value of that incoming packet and set the sequence counter value of receiver by the SC value of the packet plus 1. B also needs to calculate the hash value according to the decrypted data (SC and data segment) and then compare it with the one directly get from decrypted packet. If they are not the same, B requests A to resend the packet. 
 
 
Explanation about the code 
The language used for programming is C. The program works on RC4 algorithm and uses RC4- BHF as a hash function .Following are the programming requirements of this project. 
For Sender: 
1. The sender divides the input plaintext message into contiguous 252-byte data segments and assigns SC to each of them. The sequence counter (SC) value is increased by 1 in increased order (initially SCA = 0). If there are not enough data in the data segment of the last data packet, pad a 1 followed by as many 0 as necessary. 
2. The sender calculates the hash value for that data packet by inputting SC and the unencrypted data segment, and then places the 128-bit hash value into the data packet. 
3. The sender produces the encrypted data packets by only encrypting data segment and hash value (do not encrypt SC value). The sender updates its SCA and (S, i, j) A after the encryption. 
For Receiver: 
Initially (S, i, j)B = (S, i, j)0 and SCB = 0. When receiving a new packet, B compares its own SC value (SCB) with the SC value of the packet. If the difference of the SC value of the packet and its own SC value (SCpacket - SCB) is 0, then (S, i, j)B is used as the RC4 state to decrypt the data segment and hash value of that incoming packet and then increase the sequence counter by 1. Otherwise, calculate the right RC4 state from current (S, i, j)B by applying certain rounds of PRGA or IPRGA, and then use the right RC4 state 3 to decrypt the data segment and hash value of that incoming packet and set the sequence counter value of receiver by the SC value of the packet plus 1. B also needs to calculate the hash value according to the decrypted data (SC and data segment) and then compare it with the one directly get from decrypted packet. If they are not the same, B requests A to resend the packet. 
